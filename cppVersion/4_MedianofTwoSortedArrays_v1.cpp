#include <algorithm>
#include <climits>
#include <cmath>
#include <cstddef>
#include <iostream>
#include <iterator>
#include <queue>
#include <strings.h>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;
class Solution {
public:
  double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {
    // 两个数组的长度都有可能等于0,但是它们的和大于等于1,所以至少有一个是有长度的
    // 所以比较一下两个数组的长短然后处理非常关键
    //
    // 难点:
    // 随后想了想发现一种特殊的情况,就是现在有一个小的数组,它的范围被另一个大的数组完全覆盖,
    // 也就是说头和尾都是另一个大数组的,而且终点也属于大数组.
    // 这样的话这个分割点,就是完全在大数组上,和小数组没有关系,如果你从小数组开始讨论的话,那也就意味着你去找不到这个点
    //
    // 原因分析:
    // 这个情况我开始没有想到,是在后面偶然的机会想到的,所以一开始还是要对这个例子进行一个各种情况尽量多的一个分析,
    // 让你尽量的熟悉这个题目,也就是说这个题目你读了一遍,你以为你懂了,也许一些情况你还是没有考虑到
    //
    // 但是另一个问题出来了,
    // 这个终点的切点有可能在短的上,有可能在长的上,你现在可以想象两个数组合并之后,
    // 它可以是各种各样的组合,有可能终点被以前是短的数组占据,也有可能是被长的,那这种情况该如何考虑
    // 所以, 可以设置三种情况讨论, 第一种是正常的, 第二种在短的上面 第三种在长的
    //
    // 关键原则:
    // 一开始不要想着多么简单简洁的代码,
    // 不要想着半个小时就能解决一道难题, 慢慢来
    //
    // 思考:
    // 1. 正常的逻辑就是切点在两个数组上, 实际上也不算特别的正常,
    // 也许这个"正常"的思路来源于你已经知道了答案
    //
    int l = 0, r = nums1.size() - 1;
    // 第1个难点就是合法值的判断,是否有一个向量是长度为0
    // 如果你无法暂时找到比较简洁的代码,那么直接就分情况讨论就好了
  }
};
int main() {
  Solution s;
  cout << "hello" << endl;
}
